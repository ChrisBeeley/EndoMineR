---
title: "EndoMineR"
author: "Sebastian Zeki `r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{EndoMineR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Aims of EndoMineR

The goal of EndoMineR is to extract as much information as possible from endoscopy reports and their associated pathology specimens. 

Gastroenterology now has many standards against which practice is measured although many reporting systems do not include the reporting capability to give anything more than basic analysis. Much of the data is locked in semi-structured text. However the nature of semi-structured text means that data can be extracted in a standardised way- it just requires more manipulation. This package provides that manipulation so that complex endoscopic-pathological analyses, in line with recognised standards for these analyses, can be done.



##Introduction 

Gastroenterological data can be organised in a manner that allows several questions to be answered with the same data structure. The structure itself is straightforward. It simply rests on the basis that we mainly describe patient episodes so that each row of a dataframe pertains to the data collected at that episode and the index of the row is based on a combination of date and a patient's unique identifier
The following described an overview of how data should be structured using both and endoscopic dataset and a pathological dataset which we will merge.




##Assumptions for practical gastroenterological datasets

<br>

![Figure 1: Typical starting data set](/home/rstudio/EndoMineR/vignettes/TypicalReportForGastroDSEndoMinerVignette.svg){width=900px}

####Assumption 1 (Mandatory)- Data is episodic 

A fundamental assumption is that all patient related data at the departmental level can be viewed as pertaining to a clinical episode recorded as a single timepoint (usually as the day of the episode. A single patient is related to patient timed episodes in a one to many relationship (one patient can have many endoscopies).

####Assumption 2 (Mandatory)- Patients have unique identifiers

All patients have a unique identifier. At the departmental level this is likely to be a Trust specific hospital number.

####Assumption 3 (Optional): Outcome variables are present

A patient episode should have an outcome. In the case of an endoscopy for example, the outcome may be the histopathological diagnosis, or if no biopsies were taken, then the endoscopic diagnosis. The origin of the outcome is not important: it can be a derivative of the dataset itself or can be from a distinct dataset merged into the current one depending on the analysis. What is important is that the outcome relates to the patient episode: if biopsy result is the outcome it should be biopsies taken at the recorded endoscopy. In other words the outcome should be that which is related to the same timepoint as the event.

####Assumption 4 (Optional): Tests should have an indication

A patient episode should have a reason. The indication for the patient episode should be recorded for the same time point as the episode. This is very commonly found in report text of both an endoscopy and histopathology reports. This is optional as other analyses can still be carried out without this being available.


####Assumption 5 (Optional): The data is semi-structured.

The data is semi-structured. Structured data is easier to analyse but because it is more cumbersome to input and often lacks flexibility, most endoscopic and histopathology data remains semi-structured. This means that although the text extraction techniques outlined here are the same, the boundaries for extracting each section may differ. For example in our trust a pathology report may contain the subsections ‘Macroscopic specimen’ and ‘Diagnosis’ whereas these sections may have alternative labels in another hospital’s report.

Semi-structured data requires specific language processing techniques depending on what is being extracted. For our purposes the extractible data is likely to be either diagnoses or aspects of the test being performed. The diagnostic data is traditionally the most difficult to extract  but this is often because the object to be extracted is from a large set eg for the purposes of coding for financial remuneration. Because the target set is much smaller for endoscopic-pathological diagnoses language extraction can be more focused whilst being more flexible to accommodate edge cases such as misspellings, plurals.





## So what generic questions can we answer in gastroenterology?

The answer to this is really applicable to most areas in medicine. Many fields share the same practical, day to day questions. Although we may focus on specific questions for a specific field, the structure of many questions in medicine is the same. Based on observation and experience I think the main questions are:

**[1. Analysis patient flow](http://gastrodatascience.com/DataAnalysisEventingsSankey.html) **

If we understand the fact that patient's flow through a system, and the way to characterise that flow is by organising data according to the patient's unique identifier and episode date as a combined index, then there are a huge number of questions that can be ansered under this generic question. For example, at a population level analysis, how many patients will need to undergo further colonoscopy surveillance in 5 years based on the procedures already performed. On an individual patient level perhaps you need to know who is due to have further endoscopic follow up based on previous procedure, or which patients have been lost to follow-up. Once data is prepared in a manner that satisfies surveillance tasks, the data structure can be used for many other questions 
<br><br>

**[2. Diagnostic yields](http://gastrodatascience.com/Cornersteon_EndoPath.html)**

This relates to commonly held performance measures such as the adenoma detection rate or the pathological diagnoses per indication


**[3. Analysis of quality](http://gastrodatascience.com/Cornerstone_EndoscopicPerformance.html) **

This relates to measures such as the adequacy of sampling and documentation, adherence to minimum standards including lesion recognition performance). 

Having structured our datasets as per the previous pages, we can extract this easily as follows:


The figure above is a summary figure of how different aspects of one well constructed dataset can be used to answer questions within the spheres mentioned above


The central issue is that data is organised according to time so that the data structure is indexed by a combination of the date and the unique patient identifier. Merging with external datasets can then be done according to either the patient identifier and date or just the patient identifier if there is no need to relate the time of an episode in one data set to another.

**[Surveillance](http://gastrodatascience.com/Cornerstone_Surveillance.html)**

Surveillance programmes rely heavily on the timing of individual tests to find out when a patient is next due to undergo an investigation or to determine whether they have been lost to follow up. Analyses therefore rely on assessment of times for a patient

**[Performance metrics](http://gastrodatascience.com/Cornerstone_EndoscopicPerformance.html)**

Performance metrics depend on what is being assessed. There is a natural weighting towards endoscopy on these pages and therefore we often assess endoscopists based on their within procedure performance (how much sedation was given, the patient's comfort score etc.), as well as cross-referenceing with the results of tissue taken at the time of the procedure to assess how good we are at recognising lesions (such as the adenoma detection rate). The following pages assess these areas and given te practical recipes for resolving them in code.



##How is the package divided?


![Figure 2: Overview of all the functions](/home/rstudio/EndoMineR/vignettes/EndoMineR_FunctionStructure.svg){width=900px}

The package is basically in three parts. How all the functions are connected in Figure 2. Extracts from this figure will be used in sequential sections below.

1. **The extraction**- This is really when the data is provided as full text reports. You may already have the data in a spreadsheet in which case this part isn't necessary

2. **Cleaning**- These are a group of functions that allow the user to extract and clean data commonly found in endoscopic and pathology reports. The cleaning functions usually remove common typos or extraneous information and do some reformatting

3. **Analyses**- The analyses provide graphing function as well as analyses according to the cornerstone questions in gastroenterology- namely surveillance, patient tracking, quality of endoscopy and pathology reporting and diagnostic yield questions.




## The extractor function

Endoscopic and pathological data will come in one of two forms- either as a collection of the whole text report or as spreadsheets with some degree of separation into different columns of the various aspects of that report eg who the Endoscopist was, the patient's unique identifier etc.
For the latter, the package user will not need to Extract information as it is already extracted and so can go straight to cleaning the data. For the former the Extractor function has been provided:

<br>

![Figure 3: Extractor function](/home/rstudio/EndoMineR/vignettes/EndoMineR_Extractor.svg)

<br>

One of the most useful functions in the package is the Extractor. Different hospitals will use different software with different headings for endoscopic reports. The extractor allows the user to define the separations in a report so that all reports can be automatically placed into a meaningful dataframe for further cleaning. This is analogous to tokenization in natural language processing. Here we use the in built datasets as part of the package. Prior to tokenization it is recommended to use the ChopperNewLine function to divide the free text up by sentence (this can be useful if not using multiline regex or you have another way of splitting the text rather than using the Extractor)

```{r exampleChopperNewLines, eval = FALSE}
v<-ChopperNewLines(Myendo,'OGDReportWhole')
```

<br>

A list of keywords is then constructed. This list is made up of the words that will be used to split the document. The Extractor then does the splitting for each pair of words, with some cleaning up and then returns the split dataframe:

```{r exampleExtractor, eval = FALSE}
Mypath<-data(PathDataFrameFinalColon)
HistolTree<-list("Hospital Number","Patient Name","DOB:","General Practitioner:",
"Date of procedure:","Clinical Details:","Macroscopic description:","Histology:","Diagnosis:","")
for(i in 1:(length(HistolTree)-1)) {
Mypath<-Extractor(Mypath,"PathReportWhole",as.character(HistolTree[i]),
as.character(HistolTree[i+1]),as.character(HistolTree[i]))
}
```



## The cleaning functions

### Endoscopic cleaning

Once the extraction has been done there are various cleaning functions provided based around the extraction of likely columns. For example if the Endoscopist name has been pulled out, the EndoscChopperEndoscopist function can be used which returns the submitted data frame with the Endoscopist column cleaned up
```{r exampleEndoscChopperEndoscopist, eval = FALSE}
EndoscChopperEndoscopist(Myendo,'Endoscopist')
```

This function performs the cleaning of common things found in the text that may cause confusion. The function itself is shown below:

```{r exampleEndoscChopperEndoscopistWhole, eval = FALSE}
EndoscChopperEndoscopist <- function(x, y) {
    # Extraction of the Endoscopist
    x <- data.frame(x)
    x[, y] <- gsub("Dr", "", x[, y], fixed = TRUE)
    x[, y] <- gsub("Mr", "", x[, y], fixed = TRUE)
    x[, y] <- gsub("[^[:alnum:],]", "", x[, y])
    # Put gaps between names
    x[, y] <- gsub("([a-z])([A-Z])", "\\1 \\2", x[, y])
    x[, y] <- gsub("2nd.*", "", x[, y])
    x[, y] <- trimws(x[, y], which = c("both"))
    
    return(x)
}

```


<br>

![Figure 4: Endoscopy Cleaning functions](/home/rstudio/EndoMineR/vignettes/EndoMineR_EndoscopyClean.svg)

<br>

The EndoscChopperMeds currently extracts Fentanyl and Midazolam doses into a separate column and reformats them as numeric columns so further calculations can be done. In future iterations pethidine, propofol and general anaesthetic will also be able to be extracted. 

Several other similar clean up functions are available for Endoscopy as follows:
```{r exampleEndoCleaningFunc, eval = FALSE}
v<-EndoscChopperMeds(Myendo,'Medications')
v<-EndoscChopperInstrument(Myendo,'Instrument')
v<-EndoscChopperIndications(Myendo,'Indications')
v<-EndoscChopperProcPerformed(Myendo,'ProcedurePerformed')
```

Future iterations will try to make these cleaning functions more generic and applicable to a wider number of use cases

### Histological cleaning

The cleaning functions for histology are a little more difficult as Histology reports often have a greater degree of free text reporting.
In general, each histology reports can be divided into the Macroscopic description of a specimen which itself is comprised of how many specimens there are for each sample sent (a sample can be a pot which includes several specimens) and how big each specimen is. The report will often give a detailed description of what is actually seen and then provide an overall diagnosis.

<br>

![Figure 5: Histopathology Cleaning functions](/home/rstudio/EndoMineR/vignettes/EndoMineR_HistopExtrapol.svg)

<br>


The histology cleaning functions are based around this. For example, the HistolChopperHistol cleans the Histology text if present. In addition it removes Negative diagnoses using the Negativeremove function. This function is designed to remove all sentences that give negative diagnoses (eg "There is no evidence of...") so that false positive diagnoses are not made during the analysis stage.

This NegativeRemove function has also been applied to the HistolChopperDx

```{r exampleEHistolChopperHistol, eval = FALSE}
t<-HistolChopperHistol(Mypath,'Histology')
```

Because the information from the Macroscopic Description is based around numbers, a further function has been provided to extract numbers from the text. This function is usually only used as part of HistolChopperNumOfBx which extracts the number of biopsies taken:

```{r exampleHistolChopperMacDescrip, eval = FALSE}
HistolChopperNumbOfBx <- function(x, y, z) {
    x <- data.frame(x)
    x <- HistolChopperMacDescrip(x, y)
    mylist <- str_match_all(x[, y], paste("[0-9]{1,2}.{0,3}", z, sep = ""))
    x$NumbOfBx <- sapply(mylist, function(p) sum(as.numeric(gsub(z, "", p))))
    return(x)
}
```

In order to extract the numbers, the limit of what has to be extracted has to be set as part of the regex so that the function takes whatever word limits the selection.It collects everything from the regex [0-9]{1,2}.{0,3} to whatever the string boundary is.

```{r exampleHistolChopperNumbOfBx, eval = FALSE}
v<-HistolChopperNumbOfBx(Mypath,'Macroscopicdescription','specimen')
```

Other less useful functions include:

1. HistolChopperAccessionNumber which extracts Accession Number  data from the report where one is present.The Accession number relates to the actual specimen number as ascribed by the pathology service.

2. HistolChopperExtrapolDx which extracts other specific diagnoses from the report. These have been hard coded to 
look for dysplasia cancer and GIST. 

3. HistolChopperMacDescripCleanup. This extracts Macroscopic description data from the pathology report.Macroscopic description usually relates to the number of specimens retrieved, the size of each specimen and the location it was taken from. The cleanup usually relates to the removal of top and tail characters such as who reported the specimens etc. 

These are all called in the same way:

```{r exampleOtherFunctionsHistology, eval = FALSE}
v<-HistolChopperMacDescripCleanup(Mypath,"Macroscopicdescription")
v<-HistolChopperExtrapolDx(Mypath,"Diagnosis")
v<-HistolChopperAccessionNumber(Mypath,"Histology","SP-\\d{2}-\\d{7}")
```
v<-HistolChopperMacDescripCleanup(Mypath,"Macroscopicdescription")

<br>
<br>

## The Analysis Functions

As per the introduction the analysis functions are split according to the cornerstone questions in day to day gastroenterological practice

###Surveillance functions

Surveillance relates to the timing of a test relative to other tests or all tests done for a patient. As such the functions for surveillance extract the date the first test was done, as well as the last test and the difference in timing between each test, always grouped by patient. As all these functions are simply looking at the date of the test they can take a raw dataset, as long as a date column is present and use that, rather than have a load of pre-processing steps

<br>

![Figure 6: Surveillance functions](/home/rstudio/EndoMineR/vignettes/EndoMineR_Surveillance.svg)

<br>

```{r exampleSurveillanceTimeByRow, eval = FALSE}
em<-SurveillanceTimeByRow(Myendo,'HospitalNumber','Dateofprocedure')
em<-SurveillanceLastToNow(Myendo,'HospitalNumber','Dateofprocedure')
em<-SurveillanceLastTest(Myendo,'HospitalNumber','Dateofprocedure')
em<-SurveillanceFirstTest(Myendo,'HospitalNumber','Dateofprocedure')
```

Of course we also want to know how many tests have been done over a time period and this is provided by two functions

```{r exampleSurveillanceCapacity, eval = FALSE}
em<-SurveillanceCapacity(Myendo,"Dateofprocedure)
```


This function will return the number of tests by month. The more detailed function is:

```{r exampleHowManyTests, eval = FALSE}
how<-HowManyTests(Myendo,'Indications','Dateofprocedure','Surv')
```


This will provide the number of tests by month and year as a table as well as a ggplot. It returns aa list so this can be accessed with how[1] and how[2]

###Patient flow functions

We often like to get an overview of how patients are flowing through a system overall. This can give a nice visual representation of whether which patients diverge from the normal flow through a system so we can study them further. There are two ways to look at this. Sankey plots give good timepoint by timepoint representation of flow. This really works with more than one type of event at each timepoint. 
For example, if we have a dataset with events such as 'radiofrequency ablation' and 'endoscopic mucosal resection' or 'nothing' we can use the Sankey plot to determine the order of events over a large patient population:


```{r exampleSurveySankey, eval = FALSE}
how<-SurveySankey(Myendo,"ProcPerformed")
```

<br>

![Figure 7: SurveySankey function](/home/rstudio/EndoMineR/vignettes/EndoMineR_Sankey.svg){width=600px}

<br>

We may was something even more aggregated. Perhaps we want to see the overall number of patients that go from one event to another regardless of which timepoint it is at. To do this we can use a circos plot, which makes use of the circlize library, as follows:

```{r examplePatientFlow_CircosPlots, eval = FALSE}
flow<-PatientFlow_CircosPlots(v,"Dateofprocedure","HospitalNumber","ProcedurePerformed")
```

<br>

![Figure 8: Circos function](/home/rstudio/EndoMineR/vignettes/EndoMineR_Circos.svg){width=600px}

<br>

###Assessment of quality functions

Quality is measured in a variety of different ways. For endoscopy it is measured according to the adherence to standards for endoscopic documentation as well as detection of certain pathological conditions such as dysplasia.


####Documentation Quality
As regards adherence to documentation for example, a generic function is provided that will look up the presence of words presented in a list in a target column. It will then output the proportion of reports that have these words, as well as a barchart to show what proportion of the endoscopies showed these words. The list can be comprised on terms that should be mentioned in a report.

```{r exampleListLookup, eval = FALSE}
tt<-ListLookup(Myendo,'Findings',myNotableWords)
```

####Endoscopic Quality
Another measure of quality is by looking at those factors that are recorded at endoscopy such as degree of sedation used etc. Rather than provide a function for each metric, again a generic function is provided that uses any quantifiable metric and plots it against the endoscopist. This function returns a list with two elements- the plot and the table

```{r exampleEndoscChopperMeds, eval = FALSE}
Myendo<-EndoscChopperMeds(Myendo,'Medications')
MetricByEndoscopist(Myendo,'Endoscopist','Fent')
```

<br>

![Figure 9: MetricbyEndoscopist function](/home/rstudio/EndoMineR/vignettes/MetricByEndoscopist.png){width=600px}

<br>

Although not strictly a measure of endoscopic quality, the location of polyps (as well as any sample location) can also be determined. This is particularly for lower GI endoscopy and can help determine whether, for example, the number of right sided polyps is lower than it should be for certain endoscopists.

To do this firstly the free text needs to be standardised. This is provided through the function TermStandardLocation which provides a standard correction for a number of typos and alternative spellings.

```{r exampleTermStandardLocation, eval = FALSE}
f<-TermStandardLocation(Mypath,'Histology')
```

Once this is done, a column called SampleLocation is appended to the existing dataset. If polyps need to be located then the PolypLocator function can be used. Alternatively the SampleLocator can be used. As they append differently named columns to the existing dataset, both can be used together. The polyps text often need a bit of tidying up and this can be done with the function PolypTidyUpLocator prior to using PolypLocator

```{r examplePolypTidyUpLocator, eval = FALSE}

f<-PolypTidyUpLocator(f,'SampleLocation')
f<-PolypLocator(f,'SampleLocation') 
f<-SampleLocator(f,'SampleLocation')
```



A further difficult area is the assessment of endoscopic quality by looking at the pathology processed from an endoscopy. This package is excellent at dealing with this kind of question because of its ability to merge the datasets together:

A particularly well developed area to look at is that of the Global Rating Scale for assessing the quality of colonoscopy. One of the metrics- the adenoma detection rate assesses the number of colonoscopies where at least one adenoma was detected.

One function is provided to produce a table that gives the number of adenomas, adenocarcinomas and hyperplastic polyps (also as a ration to adenomas) by endoscopist therefore immediately fulfilling the GRS reqquirement for the ADR as well as provding further metrics alongside

```{r exampleGRS_Type_Assess_By_Unit, eval = FALSE}
GRSTable<-GRS_Type_Assess_By_Unit(v,'ProcedurePerformed','Endoscopist','Diagnosis','Histology')
```


##Application to specific disease entities- Barrett's oesophagus

The functions above really act as building blocks for the further, more complex analyses we can do for specific Endoscopic-pathological disease sets

One particular disease, the premalignant oesophageal condition Barrett's oesophagus, requires endoscopic surveillance and the timing of this depends on the prior endoscopic features (namely the length of the Barretts segment as measured by the Prague score) and the pathological stage at that endoscopy (which for non-dysplastic samples, since the revised 2013 guidelines, means the presence or absence of intestinal metaplasia)



<br>

###Pre-processing Barrett's samples

Such a dataset needs some processing prior to the analysis so for this we can turn to a specific set of function for Barrett's oesophagus itself. 

<br>

![Figure 10: Barretts cleaning functions](/home/rstudio/EndoMineR/vignettes/EndoMineR_Barretts.svg){width=600px}

<br>

####Prague score

Firstly we need to extract the length of the Barrett's segment. After filtering for indication (eg "Surveillance-Barrett's") the aim of the following function is to extract a C and M stage (Prague score) for Barrett's samples. This is done using a regex where C and M stages are explicitly mentioned in the free text. Specfically it extracts the Prague score.

```{r exampleBarrettsDataAccord_Prague, eval = FALSE}
v<-BarrettsDataAccord_Prague(Myendo,'Findings')
```

####Worst pathological stage

We also need to extract the worst pathological stage for a sample, and if non-dysplastic, determine whether the sample has intestinal metaplasia or not. This is done using 'degradation' so that it will look for the worst overall grade in the histology specimen and if not found it will look for the next worst and so on. It looks per report not per biopsy (it is more common for histopathology reports tocontain the worst overall grade rather than individual biopsy grades). Specfically it extracts the histopathology worst grade. 


```{r exampleBarrettsDataAccord_PathStage, eval = FALSE}
b<-BarrettsDataAccord_PathStage(v,'Histology')
```


####Therapeutic events

We also need to process any endoscopies where an event other than surveillance happened (unless filtered specifically for surveillance. This function extracts the Event- usually a therapeutic event, from the text eg endoscopic mucosal resection, radiofrequency ablation etc. It does not currently include stricture dilatation.Specfically it extracts the event. At the moment the event is extracted from the endoscopy only but for specimen extraction eg endoscopic mucosal resection future iterations may also examine the pathology data as it is likely to describe the presence of EMR more robustly. 


```{r exampleBarrettsDataAccord_Event, eval = FALSE}
v<-Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",Mypath,"Dateofprocedure","HospitalNumber")
b<-BarrettsDataAccord_Event(v,'Histology', 'ProcedurePerformed','OGDReportWhole','Findings')
```



####Follow-up groups

Having done these pre-processing steps, the follow-up group to which the last endoscopy belongs (rather than the patient as their biopsy results or Barrett's segment length and therefore their follow-up timing, may fluctuate over time) can be determined.


```{r exampleBarrettsDataAccord_FUGroup, eval = FALSE}
v<-Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",Mypath,"Dateofprocedure","HospitalNumber")
b<-BarrettsDataAccord_PathStage(v,'Histology')
b2<-BarrettsDataAccord_Event(b,'Histology','ProcedurePerformed','OGDReportWhole','Findings')
b3<-BarrettsDataAccord_FUGroup(b2,'Findings')
```


###Basic surveillance questions- who is undergoing endoscopic surveillance and who should we be surveying?


####Enrollment rates to surveillance programme

So now this has been determined we can continue to some more advanced analyses. We can determine how many patients who underwent endoscopy for reasons that was not Barrett's surveillance, and in whom Barrett's oesophagus was found, have had further follow-up endoscopies ie what the enrollment to surveillance rate is in those who weren't known to have Barrett's when their endoscopy was performed.

This function graphs the patients who were not on surveillance programmes and sees how many then had an endoscopy. This should be run after the BarrettsDataAccord_Prague and BarrettsDataAccord_PathStage.

```{r exampleBarrettsPatientTracking_Enrollment_Surveillance, eval = FALSE}
Enroll<-BarrettsPatientTracking_Enrollment_Surveillance(Myendo,'HospitalNumber','Dateofprocedure','Indications')
```


####Patients undergoing surveillance

Perhaps we are also interested in how many patients fall under each follow-up category so we can plan how many Barrett's surveillance endoscopies we are going to have to do. The function to do this gets the unique patient ID's for each patient, for each rule. It lists the unique PatientIDs assocaited with a rule ('Rule1','Rule2','Rule3','NoRules'). This allows us to determine how many patients will need follow up at specific time intervals. This should be run after the BarrettsDataAccord_Prague and BarrettsDataAccord_PathStage.

```{r exampleBarrettsPatientTracking_UniqueHospNum, eval = FALSE}
v<-Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",v,"Dateofprocedure","HospitalNumber")
b1<-BarrettsDataAccord_Prague(v,'Findings')
b2<-BarrettsDataAccord_PathStage(b1,'Histology')
b3<-BarrettsDataAccord_Event(b2,'Histology','ProcedurePerformed','OGDReportWhole','Findings')
b4<-BarrettsDataAccord_FUGroup(b3,'Findings')
colnames(b4)[colnames(b4) == 'pHospitalNum'] <- 'HospitalNumber'
Rule<-BarrettsPatientTracking_UniqueHospNum(b4,'Rule1','HospitalNumber')
```

###Quality assessment in Barrett's surveillance

####Quality of documentation for Barrett's surveillance endoscopies

As we have done above, we can also assess the documentation used in Barrett's endoscopies. There are standards associated with the endoscopies that all endoscopists should adhere to. This function therefore assesses the Barrett's documentation. This notes how many reports contain the mandatory report fields as specified in the BSG standards on  Barrett's endoscopic reporting. This should be run after the BarrettsDataAccord_Prague as assessment of the Prague score is a part of this assessment:

```{r exampleBarrettsQuality_AnalysisDocumentation, eval = FALSE}
v<-Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",v,"Dateofprocedure","HospitalNumber")
b<-BarrettsDataAccord_PathStage(v,'Histology')
BarrettsQuality_AnalysisDocumentation(b,"Findings")
```


<br>

![Figure 11: Barretts documentation quality function](/home/rstudio/EndoMineR/vignettes/Rplot.png){width=600px}

<br>

####Quality of perfomance of Barrett's surveillance endoscopies as just by tissue sampling

One of the essential requirements to demonstrate adequate sampling of Barrett's oesophagus during endoscopy is that the endoscopist should adhere to the 'Seattle protocol' for biopsies which is to take  4 equally spaced biopsies at 2cm intervals in the circumferential part of the oesophagus. Because the macroscopic description of the pathological specimen tells us how many samples are taken overall (and rarely how many at each level but this is usually not the case for a variety of reasons) we can determine the shortfall in the number of biopsies taken, per endoscopist. Again pre-processing the Barrett's samples is pre-requisite.

```{r exampleBarrettsQuality_AnalysisBiopsyNumber, eval = FALSE}
# Firstly relevant columns are extrapolated from the
 # Mypath demo dataset. These functions are all part of Histology data
 # cleaning as part of the package.
 v<-HistolChopperDx(Mypath,'Diagnosis')
 v<-HistolChopperExtrapolDx(v,'Diagnosis')
 v<-HistolChopperNumbOfBx(v,'Macroscopicdescription','specimen')
 v<-HistolChopperBxSize(v,'Macroscopicdescription')
 # The histology is then merged with the Endoscopy dataset. The merge occurs
 # according to date and Hospital number
 v<-Endomerge2(Myendo,'Dateofprocedure','HospitalNumber',v,'Dateofprocedure',
 'HospitalNumber')
 # The function relies on the other Barrett's functions being run as well:
 b1<-BarrettsDataAccord_Prague(v,'Findings')
 b2<-BarrettsDataAccord_PathStage(b1,'Histology')
 b3<-BarrettsDataAccord_Event(b2,'Histology',
 'ProcedurePerformed','OGDReportWhole','Findings')
 # The follow-up group depends on the histology and the Prague score for a
 # patient so it takes the processed Barrett's data and then looks in the
# Findings column for permutations of the Prague score.
 b4<-BarrettsDataAccord_FUGroup(b3,'Findings')
 colnames(b4)[colnames(b4) == 'pHospitalNum'] <- 'HospitalNumber'
 # The number of average number of biopsies is then calculated and
 # compared to the average Prague C score so that those who are taking
 # too few biopsies can be determined
 BarrettsQuality_AnalysisBiopsyNumber(b4,'Date.x','HospitalNumber',
                                      'Endoscopist')
```
 <br>
 
 ![Figure 12: Barretts quality of biopsying function](/home/rstudio/EndoMineR/vignettes/Barretts_Shortfall.png){width=600px}
 
 <br>
 
 
 <br>
 
 This function will again return a list with a ggplot showing the shortfall per endoscopist as well as a table with the same values

####Quality of perfomance of Barrett's surveillance endoscopies

As we discovered with some of the generic functions above, one way to determine quality of endoscopy is to assess the pathology of specimens taken at surveillance per year. This function outputs a plot which determines the the overall number of pathologies (low/high grade dysplasia and cancer) for patients on surveillance.

```{r exampleBarrettsSurveillance_PathDetection, eval = FALSE}
Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",v,"Dateofprocedure","HospitalNumber")
b1<-BarrettsDataAccord_Prague(v,'Findings')
b2<-BarrettsDataAccord_PathStage(b1,'Histology')
b3<-BarrettsDataAccord_Event(b2,'Histology','ProcedurePerformed','OGDReportWhole','Findings')
b4<-BarrettsDataAccord_FUGroup(b3,'Findings')
colnames(b4)[colnames(b4) == 'pHospitalNum'] <- 'HospitalNumber'
BarrettsSurveillance_PathDetection(b4,'Myplot')
```
 
<br>
  
 ![Figure 13: EMR by pathology grade](/home/rstudio/EndoMineR/vignettes/BarrettsEMR_By_Pathology.svg){width=600px}
 
<br>
 
 This function provides a plot with absolute numbers of pathology detected. This of course doesn't tell us the per endoscopist rate so a further function is provided which looks specifically at the detection of dysplasia by endoscopist as a function of the number of surveillance endoscopies done by that endoscopist. The output is provided as a table of proportions per endoscopist

```{r exampleBarrettsSurveillanceDDR, eval = FALSE} 
 v<-Endomerge2(Myendo,"Dateofprocedure","HospitalNumber",v,"Dateofprocedure","HospitalNumber")
b1<-BarrettsDataAccord_Prague(v,'Findings')
b2<-BarrettsDataAccord_PathStage(b1,'Histology')
b3<-BarrettsDataAccord_Event(b2,'Histology','ProcedurePerformed','OGDReportWhole','Findings')
b4<-BarrettsDataAccord_FUGroup(b3,'Findings')
colnames(b4)[colnames(b4) == 'pHospitalNum'] <- 'HospitalNumber'
BarrettsSurveillanceDDR(b4,'Endoscopist','IMorNoIM')
``` 

### Assessment of Barrett's therapeutics

Barrett's patients also undergo therapeutic procedures and there are various metrics to analyse the performance of the therapy by endoscopist, as well which catheters are being used etc. To start with we can do simple things like plotting all the pathological grades of the EMRs.This should only be run after all the BarrettsDataAccord functions so that the column event is present in the dataframe.


The therapeutic functions are fairly self-explanatory. The function to determine the post EMR grade is BarrettsTherapy_Numbers_EMRsByGrade with correlation with the endoscopists Paris classification provided for with the function:
 
```{r exampleBarretts_LesionRecognitionEMR, eval = FALSE} 
Barretts_LesionRecognitionEMR(dataframe,y,z)
``` 

<br>

 ![Figure 14: Worst grade dysplasia/cancer function](/home/rstudio/EndoMineR/vignettes/GradeBarretts.svg){width=600px}

<br>

 In order to determine the basic number of EMR, RFA and APC a function called BarrettsBasicNumbers is provided which outputs a geom_line plot with the information on it.
 
```{r exampleBarrettsBasicNumbers, eval = FALSE} 
BarrettsBasicNumbers(dataframe)
``` 
 
 <br>

![Figure 15: Number of Barrett's therapeutic endoscopies by type](/home/rstudio/EndoMineR/vignettes/BarrettsBasicNumbers.svg){width=600px}

<br>


 To assess the number of different catheter types used (for renumeration purposes) the following function can be used:
 
```{r exampleBarrettsTherapeuticsRFA_ByCatheter, eval = FALSE} 
BarrettsTherapeuticsRFA_ByCatheter(dataframe)
``` 

<br>

![Figure 16: Number of Barrett's therapeutic endoscopies by type](/home/rstudio/EndoMineR/vignettes/BarrettsRFA_CatheterType.svg){width=600px}

<br>

One of the most important aspects of therapeutics is the assessment of outcome which is defined as clearance of intestinal metaplasia (CRIM), usually on at least two endoscopies. As most patients undergoing Barrett's ablation will require radiofrequency ablation after the initial endoscopic mucosal resection, we can define CRIM as being an endoscopy where the therapeutic procedure is listed as 'nothing' in the EVENT column (this will only work if the Barrett's pre-processing functions have been used)

```{r exampleBarrettsCRIM, eval = FALSE} 
BarrettsCRIM(dataframe,HospNum,EVENT)
``` 